#!/usr/bin/env tclsh

package require cmdline

### opts analyze
# parent analyze
set subcoms {ls detach pop clear help -h}

if {[lsearch $subcoms [lindex $argv 0]] >= 0} {
    set subcom [lindex $argv 0]
    set argv [lrange $argv 1 end]
} else {
    set subcom detach
}

# show help and exit
if {$subcom == "help" || $subcom == "-h"} {
    puts stderr "Usage: $argv0 \[subcom]
subcommands:
	ls:		list detached files
	detach:		detach files (default)
	pop:		pop detached files
	clear:		clear detached files
	help:		show this help"

    exit 1
}

# child analyze
set opts_list {
    ls {
	usage "ls [opts] file.."
	opts {
	    {l "show details"}
	}
    }
    detach {
	usage "[detach] file.."
	opts {}
    }
    pop {
	usage "pop [opts] file.."
	opts {
	    {a "pop all files"}
	}
    }
    clear {
	usage "clear [opts] file.."
	opts {
	    {a "clear all files"}
	}
    }
}

set opts [dict get [dict get $opts_list $subcom] opts]
set usage [dict get [dict get $opts_list $subcom] usage]

try {
    array set params [::cmdline::getoptions argv $opts $usage]
} trap {CMDLINE USAGE} {msg o} {
    puts stderr "$msg"
    exit 1
}

### init
set basepath "~/.detach"
set filepath "${basepath}/config.list"

if {![file exists $filepath]} {
    file mkdir [file dirname $filepath]
    set fp [open $filepath w+]
} else {
    set fp [open $filepath r]
}

set config_list [read $fp]
close $fp

### subcom
if {$subcom == "detach"} {
    # get last id
    if {[catch {set id_end [dict get [lindex $config_list end] id]}]} {
	set id_end 0
    }

    foreach file $argv {
	set id_end [expr $id_end + 1]

	# file move
	if {[catch {file rename $file "${basepath}/${id_end}"} err]} {
	    puts $err
	    continue
	}

	# lappend config {id, file}
	lappend config_list [list id $id_end org [file normalize $file]]
    }

    # update
    set fp [open $filepath w]
    foreach config $config_list {
        puts $fp [list $config]
    }
    close $fp

    exit
}

if {$subcom == "ls"} {
    foreach config $config_list {
	puts "[dict get $config id] [dict get $config org]"
    }

    exit
}

proc find_config {&config_list id} {
    upvar ${&config_list} config_list

# TODO index
    foreach key config $config_list {
	if {$id != [dict get $config id]} continue;
	return $config
    }
}

if {$subcom == "pop"} {
    foreach id $argv {
	set from "${basepath}/${id}"
	puts $from

	set config [find_config config_list $id]
	puts $config
    }

    exit
}


# pop <id>
# pop-all
# clear <id>
# clear-all
